### 借助 `call` 实现继承

```javascript
function Parent1() {
    this.name = 'parent1';
}
function Child1() {
    Parent1.call(this);
    this.type = 'child1';
}
console.log(new Child1());
```

可以继承父类的属性，但是无法继承父类的方法。

#Call 

### 借助 [[⛓️ prototype.png|原型链]] 实现继承

```javascript
function Parent2() {
    this.name = 'parent2';
    this.play = [1, 2, 3];
}
function Child2() {
    this.type = 'child2';
}
Child2.prototype = new Parent2();
console.log(new Child2());
var s1 = new Child2();
var s2 = new Child2();
s1.play.push(4);
console.log(s1.play, s2.play);
```

虽然可以继承父类的方法和属性，但是生成的实例使用的都是同一个原型对象。

### 借助 `call` 和 [[⛓️ prototype.png|原型链]] 组合实现继承

```JavaScript
function Parent3() {
    this.name = 'parent3';
    this.play = [1, 2, 3];
}
function Child3() {
	// 执行一次构造函数
    Parent3.call(this);
    this.type = 'child3';
}
// 执行第二次构造函数
Child3.prototype = new Parent3();
var s3 = new Child3();
var s4 = new Child3();
s3.play.push(4);
console.log(s3.play, s4.play);
```

解决了之前的问题，单指这里 `Parent3` 的构造函数会多执行一次。

### 借助寄生组合实现继承

```javascript
function Parent5() {
    this.name = 'parent5';
    this.play = [1, 2, 3];
}
function Child5() {
    Parent5.call(this);
    this.type = 'child5';
}
Child5.prototype = Object.create(Parent5.prototype);
Child5.prototype.constructor = Child5;
```
